service: stasis

frameworkVersion: ">=1.1.0 <2.0.0"

plugins:
  - serverless-domain-manager
  - serverless-python-requirements
  - serverless-aws-documentation

provider:
  name: aws
  runtime: python3.7
  region: us-west-2

  # simple security based on stages and api keys
  # one fits all for production
  apiKeys:
    - "stasis-${self:custom.stage}"

  #required permissions
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:*
      Resource: "*"

    - Effect: Allow
      Action:
        - sqs:*
      Resource: { "Fn::Join": [":", ["arn:aws:sqs:${self:custom.region}",  "*:*" ] ]  }

    - Effect: Allow
      Action:
        - s3:*
      Resource: "arn:aws:s3:::*"
    - Effect: "Allow"
      Action:
        - ecs:RunTask
        - ecs:ListTasks
      Resource: "*"
    - Effect: Allow
      Action:
        - iam:PassRole
      Resource: "*"



  memorySize: 128
  timeout: 90
  versionFunctions: false

  logRetentionInDays: 3

  #where to store out data, needs to be manually created!
  deploymentBucket:
    name: "lambdas-stasis"

############################################################################################
#custom configuration settings
############################################################################################
custom:
  stage: ${opt:stage, self:provider.stage}
  region: ${opt:region, self:provider.region}

  ###
  # Stasis resources definitions
  ###
  trackingTable: "StasisTrackingTable-${self:custom.stage}"
  acquisitionTable: "StasisMetaDataTable-${self:custom.stage}"
  jobStateTable: "StasisJobStateTable-${self:custom.stage}"
  jobTrackingTable: "StasisJobTrackingTable-${self:custom.stage}"
  resultTable: "wcmc-data-stasis-result-${self:custom.stage}"

  ###
  # Carrot resources definition
  ###
  targetTable: "CarrotTargetTable-${self:custom.stage}"
  # spectra bucket S3 or cheaper version

  ###
  # Carrot bucket definition
  ###
  dataBucketName: "data-carrot"

  ###
  # Queues
  ###
  scheduleQueue: "StasisScheduleQueue-${self:custom.stage}"

  ###
  # this queue will take care of holding all pending aggregation tasks
  aggregationQueue: "JobsAggregationQueue-${self:custom.stage}"

  ###
  # custom domain management
  ###

  domains:
    prod: api.metabolomics.us
    test: test-api.metabolomics.us
    dev:  dev-api.metabolomics.us

  customDomain:
    basePath: "stasis"
    domainName: ${self:custom.domains.${self:custom.stage}}
    stage: "${self:custom.stage}"
    createRoute53Record: true

  pythonRequirements:
    dockerizePip: true
    slim: false
    noDeploy:
      - "boto3"
      - "botocore"
      - "moto"
      - "pytest"

############################################################################################
# this section defines what to include and exclud when packaging artifacts
############################################################################################
package:
  exclude:
    - .git/**
    - .venv/**
    - .idea/**
    - .pytest_cache/**
    - venv/**
    - test/**
    - tests/**
    - node_modules/**
    - integrationTests/**

############################################################################################
# this section defines all lambda function and triggers
############################################################################################
functions:


  #fetches an result record
  resultGet:
    handler: stasis/results/get.get
    events:
      - http:
          private: true
          path: result/{sample}
          method: get
          cors: true
          documentation:
            summary: downloads a data processing result
          request:
            parameter:
              paths:
                sample: true
    #defines to which topic we want to connect
    environment:
      resultTable: ${self:custom.resultTable}

  #fetches an result record
  resultCreate:
    handler: stasis/results/create.create
    events:
      - http:
          path: result
          private: true
          method: post
          cors: true
          documentation:
            summary: uploads a new data processing result.

    #defines to which topic we want to connect
    environment:
      resultTable: ${self:custom.resultTable}


  #creates a new tracking record in the system
  trackingCreate:
    handler: stasis/tracking/create.create
    events:
      - http:
          path: tracking
          private: true
          method: post
          cors: true
          documentation:
            summary: creates a new tracking record in the database for the given sample

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #fetches an existing tracking record from the system
  trackingGet:
    handler: stasis/tracking/get.get
    events:
      - http:
          path: tracking/{sample}
          private: true
          method: get
          cors: true
          documentation:
            summary: loads the tracking information for this sample
          request:
            parameter:
              paths:
                sample: true

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #fetches an existing tracking record from the system
  trackingDelete:
    handler: stasis/tracking/delete.delete
    events:
      - http:
          path: tracking/{sample}
          private: true
          method: delete
          cors: true
          documentation:
            summary: deletes the tracking information for the given sample
          request:
            parameter:
              paths:
                sample: true

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #fetches a list of samples in an experiment
  trackingExperiment:
    handler: stasis/experiment/experiment.get
    events:
      - http:
          path: experiment/{experiment}
          method: get
          private: true
          cors: true
          documentation:
            summary: loads the complete experiment definition and this can time out for large experiments. we recommend to use the paginated approaches
          request:
            parameter:
              path:
                experiment: true
      - http:
          path: experiment/{experiment}/{psize}
          method: get
          cors: true
          private: true
          documentation:
            summary: fetches an experiment in paginated mode in the given page size
          request:
            parameter:
              path:
                experiment: true
                psize: true
      - http:
          path: experiment/{experiment}/{psize}/{lastSample}
          method: get
          cors: true
          private: true
          documentation:
            summary: iterative way to load an experiment definition. Based on the page size and the last fetched sample
          request:
            parameter:
              path:
                experiment: true
                psize: true
                lastSample: true
    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #fetches an acquisition record
  acquisitionGet:
    handler: stasis/acquisition/get.get
    events:
      - http:
          path: acquisition/{sample}
          method: get
          cors: true
          private: true
          request:
            parameter:
              paths:
                sample: true
          documentation:
            summary: fetches the acquisition information for the given sample
    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #fetches an acquisition record
  acquisitionCreate:
    handler: stasis/acquisition/create.create
    events:
      - http:
          path: acquisition
          method: post
          private: true
          cors: true
          documentation:
            summary: creates a new record with the given acquisition information

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #imports data from MiniX
  acquisitionCreateFromMinix:
    handler: stasis/acquisition/create.fromMinix
    events:
      - http:
          path: acquisition/import/minix
          private: true
          method: post
          cors: true
          documentation:
            summary: this generates an acquisition table based on past minix study data and should be avoided!

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #schedule data to stasis, for handling the processing on the backend
  schedule:
    handler: stasis/schedule/schedule.schedule
    events:
      - http:
          path: schedule
          method: post
          private: true
          cors: true
          documentation:
            summary: schedules a new processing tasks to the queue

    #defines to which topic we want to connect
    environment:
      schedule_queue: ${self:custom.scheduleQueue}

      #returns the count of scheduled tasks in the fargate cluster
  #no to be confused with the actual queue
  schedule_task_count:
    handler: stasis/schedule/schedule.scheduled_task_size
    events:
      - http:
          path: schedule/cluster/count
          method: get
          cors: true
          documentation:
            summary: returns the current scheduled tasks size

  # monitors the schedule queue and submits data for calculation
  # to the fargate cluster
  schedule_monitor:
    handler: stasis/schedule/schedule.monitor_queue
    events:
      - schedule:
          rate: rate(1 minute)
          documentation:
            summary: monitors the scheduling queue and ensures correct quantity of scheduled jobs.
    environment:
      schedule_queue: ${self:custom.scheduleQueue}
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}  #returns all statuses

  # fetches the list of tracking statuses
  statusGet:
    handler: stasis/status/get.get
    events:
      - http:
          path: status
          method: get
          private: true
          cors: true
          documentation:
            summary: returns all possible status names and their priority

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}
      acquisitionTable: ${self:custom.acquisitionTable}

  #returns all targets for a method or a target matching method and mz_rt
  targetGet:
    handler: stasis/target/get.get
    events:
      - http:
          path: target/{method}
          method: get
          private: true
          cors: true
          request:
            parameter:
              paths:
                method: true
                mz_rt: false
          documentation:
            summary: loads all targets for the given method
      - http:
          path: target/{method}/{mz_rt}
          method: get
          private: true
          cors: true
          request:
            parameter:
              path:
                method: true
                mz_rt: true

    #defines to which topic we want to connect
    environment:
      targetTable: ${self:custom.targetTable}

  #creates a target
  targetPost:
    handler: stasis/target/create.create
    events:
      - http:
          path: target
          private: true
          method: post
          cors: true
          documentation:
            summary: creates a new target

    #defines to which topic we want to connect
    environment:
      targetTable: ${self:custom.targetTable}

  #updates a target
  targetPut:
    handler: stasis/target/update.update
    events:
      - http:
          path: target
          private: true
          method: put
          cors: true
          documentation:
            summary: updates a target


    #defines to which topic we want to connect
    environment:
      targetTable: ${self:custom.targetTable}
  #updates a target
  targetDelete:
    handler: stasis/target/delete.delete
    events:
      - http:
          path: target/{method}/{mz_rt}
          method: delete
          cors: true
          private: true
          request:
            parameter:
              path:
                method: true
                mz_rt: true
          documentation:
            summary: deletes a target

    #defines to which topic we want to connect
    environment:
      targetTable: ${self:custom.targetTable}

  #return available libraries
  libraryGet:
    handler: stasis/library/get.get
    events:
      - http:
          path: library
          private: true
          method: get
          cors: true
          documentation:
            summary: lists all available libraries

    #defines to which topic we want to connect
    environment:
      targetTable: ${self:custom.targetTable}

  #checks existence of a raw data file
  fileExists:
    handler: stasis/file/exists.exists
    events:
      - http:
          private: true
          path: file/exists/{sample}
          method: get
          cors: true
          request:
            parameter:
              paths:
                sample: true
          documentation:
            summary: evaluates if a certain file exists

    environment:
      dataBucket: ${self:custom.dataBucketName}


  #creates a new tracking record in the system
  job_tracking_create:
    handler: stasis/jobs/tracking.create
    events:
      - http:
          path: job/tracking
          private: true
          method: post
          cors: true
          documentation:
            summary: updates the tracking status of a sample with the associated job

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}

  #fetches an existing tracking record from the system
  job_tracking_get:
    handler: stasis/jobs/tracking.get
    events:
      - http:
          documentation:
            summary: Returns the tacking status of a sample with an associated job
            queryParams:
              - name: job
                description: the job id
                required: true
              - name: sample
                description: the sample id
                required: true

          path: job/tracking/{job}/{sample}
          private: true
          method: get
          cors: true
          request:
            parameter:
              paths:
                job: true
                sample: true

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}

  # computes the current state of the given job
  job_tracking_status:
    handler: stasis/job/tracking.status
    events:
      - http:
          path: job/status/{job}
          private: true
          method: get
          cors: true
          request:
            parameter:
              paths:
                job: true
          documentation:
            summary: returns the overal status of the given job
            queryParams:
              - name: job
                description: the job id
                required: true

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}

  # computes the complete job
  job_description:
    handler: stasis/job/tracking.description
    events:
      - http:
          path: job/{job}
          private: true
          method: get
          cors: true
          request:
            parameter:
              paths:
                job: true
          documentation:
            summary: return the complete job description with all associated samples and there states
            queryParams:
              - name: job
                description: the job id
                required: true

    #defines to which topic we want to connect
    environment:
      trackingTable: ${self:custom.trackingTable}

  #schedule data to for handling the processing and aggregation on the backend
  job_schedule:
    handler: stasis/jobs/schedule.schedule_job
    events:
      - http:
          path: job/schedule
          method: post
          private: true
          cors: true
          documentation:
            summary: schedules a job to be computed to the backend queue

    #defines to which topic we want to connect
    environment:

      ##
      # contains scheduling events
      schedule_queue: ${self:custom.scheduleQueue}

      ##
      # contains aggregation events
      aggregation_queue: ${self:custom.aggregationQueue}

      jobStateTable: ${self:custom.jobStateTable}

      jobTrackingTable: ${self:custom.jobTrackingTable}
